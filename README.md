## 海量小文件存储方案

### 淘宝不使用海量小文件存储原因
1. 大规模的小文件存储，磁头需要频繁地寻道和换道，因此在读取上容易带来较长的延时。
2. 频繁的新增删除操作导致磁盘碎片，降低磁盘利用率和IO读写效率。
3. inode 占用了大量的磁盘空间，降低了缓存到内存的效果。将导致多次的磁盘内存swap。

### 大文件存储结构
#### 设计思路
1. 以 block 文件的形式存放数据文件，每个块都有唯一的一个整数编号，块在使用之前所用到的存储空间都会预先分配和初始化。(一般64M一个block)
2. 每一个块由一个索引文件、一个主块文件和若干个扩展块组成，“小文件”主要存放在主块中，扩展块主要用来存放溢出的数据。
3. 每个索引文件存放对应的 块信息 和 “小文件” 索引信息，索引文件会在服务启动时映射到内存，以便极大的提高文件检索速度。“小文件”索引信息采用在索引文件中的 数据结构哈希链表 来实现。
4. 每个文件有对应的文件编号，文件编号从1开始编号，依次递增，同时作为哈希查找算法的Key 来定位“小文件”在主块和扩展块中的偏移量。文件编号+块编号按某种算法可得到“小文件”对应的文件名。

#### 块初始化
* 生成主块文件
  1. 根据 id 创建主块文件
  2. 预分配空间
* 生成索引文件
  1. 根据 id 生成索引文件
  2. 头部信息初始化（块信息初始化 + 索引信息初始化）
  3. 同步写入磁盘
  4. 映射至内存访问
#### 块中写入文件
* 加载索引文件
  1. 映射索引文件到内存
* 文件信息写入主块
  1. 从索引文件中读取块数据偏移
  2. 将文件写入主块对应的偏移位置中
* 文件索引信息写入索引文件
  1. 生成 MetaInfo 信息（包括文件在块中的fd）
  2. 将 MetaInfo 写入索引文件
  3. 更新块信息 BlockInfo
### 编译
1. `mkdir bl`
2. `cd bl`
3. `cmake ..`
4. `make`
### 运行
1. bin 目录下可执行文件：
2. `./test_init 1`
3. `./test_write 1`
4. `./test_read 1 1`
5. `./test_del 1`

  
